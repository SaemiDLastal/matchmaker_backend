const CriteriaBuilder = require('./CriteriaBuilder')
const SchemaUtil = require('../util/SchemaUtil')
const ArrayUtil = require('../util/ArrayUtil')
const Link = require('./Link')
const Where = require('./Where')
for (const func of Object.values(Where)) {
  let name = func.name
  Reflect.defineProperty(func, 'name', {
    value: name[0].toUpperCase() + name.substr(1)
  })
}

module.exports = class JpaBuilder {
  constructor(sqlGenerator) {
    this._sqlGenerator = sqlGenerator
  }

  get generator() {
    return this._sqlGenerator
  }

  prepare(context, schema) { }

  build(context, repository) {
    this.buildCriteria(repository)
    repository.insert = async (context, entity) => {
      return await this.executeInsert(context, repository.schema, entity)
    }

    repository.update = async (context, entity) => {
      return await this.executeUpdate(context, repository.schema, entity)
    }

    repository.save = async (context, entity) => {
      return await this.executeSave(context, repository.schema, entity)
    }

    repository.delete = async (context, key) => {
      let primaryKey = SchemaUtil.getPrimaryKey(repository.schema)
      let where = primaryKey + '=?'
      let values = [key]
      return await this.executeDelete(context, repository.schema, where, values)
    }

    repository.clear = async (context) => {
      return await this.executeDelete(context, repository.schema)
    }

    repository.get = async (context, key) => {
      let primaryKey = SchemaUtil.getPrimaryKey(repository.schema)
      let where = primaryKey + '=?'
      let values = [key]
      let list = await this.executeSelect(context, repository.schema, where, undefined, values)
      return list.length > 0 ? list[0] : null
    }

    repository.count = async (context, specification) => {
      let where = specification ? this.execute(repository.schema, specification) : ''
      return await this.executeCount(context, repository.schema, where, [])
    }

    repository.select = async (context, specification, pageRequest) => {
      let where = specification ? this.execute(repository.schema, specification) : ''
      return await this.executeSelect(context, repository.schema, where, pageRequest, [])
    }
  }

  buildCriteria(repository) {
    Object.keys(repository).forEach(name => {
      Object.keys(CriteriaBuilder).forEach(key => {
        if (name.startsWith(key)) {
          let value = repository[name]
          if (key === 'exec') {
            repository[name] = CriteriaBuilder.exec(value)
          } else {
            let { where, argumentsLength } = this.parseQuery(repository.schema, name.substr(key.length))
            repository[name] = CriteriaBuilder[key](this, where, argumentsLength)
          }
        }
      })
    })
  }

  parseQuery(schema, query) {
    let fields = ArrayUtil.flatten(query.split('And').map(f => {
      if (f.indexOf('Or') === -1) {
        return { name: f, and: true }
      } else {
        return f.split('Or').map(f0 => {
          return { name: f0 }
        })
      }
    }))
    let argumentsLength = 0
    let foundAll = fields.every(f => {
      Reflect.ownKeys(Where).some(key => {
        let operator = Where[key]
        if (f.name.endsWith(operator.name)) {
          f.operator = key
          f.length = operator.length
          f.name = f.name[0].toLowerCase() + f.name.substr(1, f.name.length - operator.name.length - 1)
          return true
        }
      })
      if (!f.operator) {
        f.operator = 'equal'
        f.length = 1
        f.name = f.name[0].toLowerCase() + f.name.substr(1)
      }
      argumentsLength += f.length
      return SchemaUtil.hasField(schema, f.name)
    })
    if (!foundAll) {
      throw new Error(`can't assemble ${query} to repository ${schema.name}, please check fields`)
    }
    let where = this.execute(schema, function (link, proxy) {
      return fields.reduce((buf, field) => {
        let condition = proxy[field.name][field.operator]()
        if (buf) {
          return field.and ? link.and(buf, condition) : link.or(buf, condition)
        } else {
          return condition
        }
      }, false)
    })
    return { where, argumentsLength }
  }

  execute(schema, specification) {
    let target = this.createObject(schema)
    try {
      return specification(Link, target.proxy)
    } finally {
      target.revoke()
    }
  }

  createObject(schema) {
    let fields = {}
    let { proxy, revoke } = Proxy.revocable({}, {
      get: (_, name) => {
        if (!fields[name]) {
          if (SchemaUtil.hasField(schema, name)) {
            fields[name] = this.createField(name)
          } else {
            throw new Error(`not found ${schema.name}.${name}`)
          }
        }
        return fields[name].proxy
      }
    })
    return {
      proxy,
      revoke: function () {
        revoke()
        Object.values(fields).forEach(field => field.revoke())
      }
    }
  }

  createField(name) {
    return Proxy.revocable({}, {
      get: (_, operator) => {
        if (Reflect.has(Where, operator)) {
          return (...args) => {
            args = args.map(arg => this.generator.encode(arg))
            return '`' + name + '`' + Where[operator](...args)
          }
        } else {
          throw new Error('unsupported operator: ' + operator)
        }
      }
    })
  }

  async executeInsert(context, schema, entity) {
    return await context.query(this.generator.getInsert(schema, entity))
  }

  async executeUpdate(context, schema, entity) {
    let sql = this.generator.getUpdate(schema, entity)
    if (sql) {
      return await context.query(sql)
    }
  }

  async executeSave(context, schema, entity) {
    return await context.query(this.generator.getSave(schema, entity))
  }

  async executeCount(context, schema, where, values) {
    let result = await context.query(this.generator.getCount(schema, where), values)
    return result[0].value
  }

  async executeSelect(context, schema, where, pageRequest, values) {
    return await context.query(this.generator.getSelect(schema, where, pageRequest), values)
  }

  async executeDelete(context, schema, where, values) {
    return await context.query(this.generator.getDelete(schema, where), values)
  }
}
