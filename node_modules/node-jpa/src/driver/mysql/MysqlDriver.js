const mysql = require('mysql')
const Driver = require('../Driver')
const MysqlConnection = require('./MysqlConnection')
const MysqlJpaBuilder = require('./MysqlJpaBuilder')
const DEFAULT = {
  connectionLimit: 10,
  queueLimit: 10,
  timezone: '+0800',
  timeout: 5000
}

module.exports = class MysqlDriver extends Driver {
  constructor(config) {
    super()
    this._config = Object.assign({}, DEFAULT, config)
    this._connections = new Map()
    this._pool = mysql.createPool(this._config)
    this._pool.on('enqueue', () => {
      console.warn('waiting for available connection slot')
      this.recycleConnections()
    })
    this._pool.on('release', (instance) => {
      this._connections.delete(instance)
    })
  }

  get config() {
    return this._config
  }

  escape(value) {
    return this._pool.escape(value)
  }

  getConnection() {
    return new Promise((resolve, reject) => {
      this._pool.getConnection((err, instance) => {
        if (err) {
          reject(err)
        } else if (instance) {
          let connection = new MysqlConnection(instance)
          this._connections.set(instance, connection)
          resolve(connection)
        }
      })
    })
  }

  getJpaBuilder() {
    return new MysqlJpaBuilder(this)
  }

  release() {
    this._pool.end()
  }

  async recycleConnections() {
    let now = Date.now()
    for (let instance of this._connections.keys()) {
      let connection = this._connections.get(instance)
      if (connection && now - connection.timestamp > this._config.timeout) {
        console.warn('found a leak mysql connection')
        this._connections.delete(instance)
        await connection.rollback()
        connection.destroy()
      }
    }
  }
}
